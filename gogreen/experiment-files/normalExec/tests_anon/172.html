
<html>
<head>
<script>
var testFunc = function() {

    let payloads = [];
    let promises = [];


    /**
     * Resolve all promises and track
     * @return {Promise}
     */
    const resolveAndTrack = () => Promise
        .all(promises)
        .then((newPayloads) => {
            payloads = payloads.concat([].concat(...newPayloads));
            payloads.forEach(monetatePush);
            promises = [];
            monetateTrack();
        });

    /**
     * Check if the payload is an object
     * @param {any} obj
     * @return {boolean}
     */
    const isObject = (obj) => {
        if (obj instanceof Array) return false; // array also considered object
        return obj instanceof Object;
    }

    /**
     * @param obj - methodName/methodData pairs, e.g. {setPageType: 'products', addProducts: ['a123']}
     * @return {Array|void}
     */
    const toArray = (obj) => {
        return Object
            .keys(obj)
            .map((methodName) => [methodName, obj[methodName]]);
    }

    return {

        /**
         * Add data to currentPayload for further sending to Monetate
         * @param {Object|Promise} promise
         * @return {Object} - self for daisy chaining
         */
        push: function(promise) {
            promises.push(promise.then(toArray));
        },

        /**
         * Send only current payload
         * @return {Promise} for testing
         */
        track: function() {
            payloads = [];
            return resolveAndTrack();
        },

        /**
         * Send current and previous payloads
         * @return {Promise} for testing
         */
        retrack: function() {
            return resolveAndTrack();
        },

    };
}
</script>
</head>
<body>
<div id="res">Failed</div>
<script>
let failed = true;
try {
    testFunc();
    failed = false;
} catch (e) {
    failed = true;
}

document.getElementById("res").innerHTML = failed ? "Failed" : "Ok";
</script>
</body>
</html>
